const clone = require('lodash.clonedeep')

const CO2_PER_GALLON = 8.887 // Kilograms of CO2 burned per gallon of gasoline
const CYCLING_MET = 8 // Find MET scores here: http://appliedresearch.cancer.gov/atus-met/met.php
const METERS_TO_MILES = 0.000621371
const SECONDS_TO_HOURS = 1 / 60 / 60
const WALKING_MET = 3.8

const CO2_PER_TRANSIT_TRIP = 239000000 / 200000000 // CO2 per passenger trip. Kilograms of CO2 / Rides. http://www.wmata.com/Images/Mrel/MF_Uploads/sustainability-web-2014-04-22.pdf

const DEFAULT_TIME_FACTORS = {
  calories: -0.01,
  carParking: 5,
  co2: 0.5,
  cost: 5,
  transfer: 5
}

const DEFAULT_RATES = {
  bikeSpeed: 4.1, // in m/s
  carParkingCost: 10,
  co2PerTransitTrip: CO2_PER_TRANSIT_TRIP,
  mileageRate: 0.56, // IRS reimbursement rate per mile http://www.irs.gov/2014-Standard-Mileage-Rates-for-Business,-Medical-and-Moving-Announced
  mpg: 21.4,
  walkSpeed: 1.4, // in m/s
  weight: 75 // in kilograms
}

module.exports = ProfileScore

/**
 * Process & score an OTP Profile response. Tally statistics, score options.
 *
 * @param {Object} opts Options object.
 * @param {Object=} opts.factors Factors to override the defaults.
 * @param {Object=} opts.rates Rates to to override the defaults.
 * @example
 * const ProfileScore = require('otp-profile-score')
 * const scorer = new ProfileScore({ factors: {}, rates: {} })
 */

function ProfileScore (opts) {
  opts = opts || {}

  this.factors = merge(DEFAULT_TIME_FACTORS, opts.factors || {})
  this.rates = merge(DEFAULT_RATES, opts.rates || {})
}

/**
 * Process an individual option, only uses the first access and egress modes given.
 *
 * @param {Object} option Option returned from OTP's profiler.
 * @returns {Object} processedOption Annotated and scored.
 * @example
 * getProfileFromOTP(query, function(err, profile) {
 *   const scoredOption = scorer.processOption(profile[0])
 * })
 */

ProfileScore.prototype.processOption = function (option) {
  // Tally the data
  option = this.tally(option)

  // Score the option
  option.score = this.score(option)

  return option
}

/**
 * Process an array of options that were generated by [OpenTripPlanner](http://www.opentripplanner.org)'s Profiler.
 *
 * @param {Array} options
 * @returns {Array} processedOptions Options that are split up by access mode and annotated with a score.
 * @example
 * getProfileFromOTP(query, function(err, profile) {
 *   const allScoredResults = scorer.processOptions(profile)
 * })
 */

ProfileScore.prototype.processOptions = function (options) {
  const processed = []
  const self = this

  options.forEach(function (option) {
    if (option.access) {
      option.access.forEach(function (a, accessIndex) {
        if (option.egress && option.egress.length > 0) {
          option.egress.forEach(function (e, egressIndex) {
            const opt = clone(option)
            opt.access = [clone(a)]
            opt.egress = [clone(e)]
            processed.push(self.processOption(opt))
          })
        } else {
          const opt = clone(option)
          opt.access = [clone(a)]
          processed.push(self.processOption(opt))
        }
      })
    }
  })

  processed.sort(function (a, b) {
    return a.score - b.score
  })

  return processed
}

/**
 * Get the weighted score of an option based on the factors, weights, and tallied totals for that option.
 *
 * @param {Object} option
 * @returns {number} score
 */

ProfileScore.prototype.score = function (option) {
  const factors = this.factors
  let score = option.time / 60
  let totalCalories = 0

  option.modes.forEach(function (mode) {
    switch (mode) {
      case 'car':
      case 'car_park':
        // Add time for parking
        score += applyFactor(1, factors.carParking)

        // Add time for CO2 emissions
        score += applyFactor(option.emissions, factors.co2)
        break
      case 'bicycle':
      case 'bicycle_rent':
        // Add time for locking your bike
        score += applyFactor(1, factors.transfer)
        totalCalories += option.bikeCalories
        break
      case 'walk':
        totalCalories += option.walkCalories
        break
    }
  })

  // Add time for each transfer
  score += applyFactor(option.transfers, this.factors.transfer)

  // Add time for each dollar spent
  score += applyFactor(option.cost, this.factors.cost)

  // Add/subtract time for calories
  score += applyFactor(totalCalories, this.factors.calories)

  return score
}

/**
 * Tally values. Add up total calories, cost, transfers, distances, and times.
 *
 * @param {Object} option
 * @returns {Object} talliedOption
 */

ProfileScore.prototype.tally = function (option) {
  // Defaults
  option.bikeCalories = 0
  option.calories = 0
  option.cost = 0
  option.emissions = 0
  option.modes = []
  option.time = 0
  option.timeInTransit = 0
  option.transfers = 0
  option.transitCost = 0
  option.walkCalories = 0

  // Bike/Drive/Walk distances
  option.bikeDistance = 0
  option.driveDistance = 0
  option.walkDistance = 0

  // Tally access
  if (option.access && option.access.length > 0) {
    const access = option.access[0]
    const accessMode = access.mode.toLowerCase()

    addStreetEdges(option, accessMode, access.streetEdges)

    option.time += access.time
  }

  // Tally egress
  if (option.egress && option.egress.length > 0) {
    const egress = option.egress[0]
    const egressMode = egress.mode.toLowerCase()

    addStreetEdges(option, egressMode, egress.streetEdges)

    option.time += egress.time
  }

  // Tally transit
  if (option.transit && option.transit.length > 0) {
    option.transfers = option.transit.length - 1
    option.transitCost = 0
    option.trips = Infinity

    const self = this
    option.transit.forEach(function (segment) {
      option.modes.push(segment.mode.toLowerCase())

      const trips = segment.segmentPatterns ? segment.segmentPatterns[0].nTrips : 0
      if (trips < option.trips) option.trips = trips

      // Total & add the time in transit
      const timeInTransit = (segment.waitStats.avg + segment.rideStats.avg)
      option.timeInTransit += timeInTransit

      // Add walk time, wait time, & ride time
      option.time += segment.walkTime + timeInTransit

      // Increment the total walk distance
      option.walkDistance += segment.walkDistance

      // Add CO2 per transit leg
      option.emissions += self.rates.co2PerTransitTrip
    })

    if (option.fares) {
      option.fares.forEach(function (fare) {
        if (fare && fare.peak) option.transitCost += fare.peak
      })
    }

    option.cost += option.transitCost
  }

  // Set the walking calories burned
  if (option.modes.indexOf('walk') !== -1) {
    option.walkCalories = caloriesBurned(WALKING_MET, this.rates.weight, (option.walkDistance / this.rates.walkSpeed) *
      SECONDS_TO_HOURS)
  }

  // Set the biking calories burned
  if (option.modes.indexOf('bicycle') !== -1 || option.modes.indexOf('bicycle_rent') !== -1) {
    option.bikeCalories = caloriesBurned(CYCLING_MET, this.rates.weight, (option.bikeDistance / this.rates.bikeSpeed) *
      SECONDS_TO_HOURS)
  }

  // Set the parking costs
  if (option.modes.indexOf('car') !== -1 || option.modes.indexOf('car_park') !== -1) {
    option.carCost = this.rates.mileageRate * (option.driveDistance * METERS_TO_MILES) + this.rates.carParkingCost
    option.cost += option.carCost
    option.emissions = option.driveDistance / this.rates.mpg * CO2_PER_GALLON
  }

  // unique modes only
  option.modes = option.modes.reduce(function (modes, mode) {
    return modes.indexOf(mode) === -1 ? modes.concat(mode) : modes
  }, [])

  // Total calories
  option.calories = option.bikeCalories + option.walkCalories

  return option
}

function addStreetEdges (option, mode, streetEdges) {
  if (!streetEdges) return
  option.modes.push(mode)

  switch (mode) {
    case 'car':
    case 'car_park':
      option.driveDistance += streetEdgeDistanceForMode(streetEdges, 'car')
      break
    case 'bicycle':
      option.bikeDistance += streetEdgeDistanceForMode(streetEdges, 'bicycle')
      break
    case 'bicycle_rent':
      option.modes.push('walk')
      option.bikeDistance += streetEdgeDistanceForMode(streetEdges, 'bicycle')
      option.walkDistance += streetEdgeDistanceForMode(streetEdges, 'walk')
      break
    case 'walk':
      option.walkDistance += streetEdgeDistanceForMode(streetEdges, 'walk')
      break
  }
}

function streetEdgeDistanceForMode (streetEdges, mode) {
  let currentMode = 'walk'
  return streetEdges.reduce(function (distance, step) {
    if (step.mode) {
      currentMode = step.mode.toLowerCase()
    }
    if (currentMode === mode) {
      distance += step.distance
    }
    return distance
  }, 0)
}

function caloriesBurned (met, kg, hours) {
  return met * kg * hours
}

function applyFactor (v, f) {
  if (typeof f === 'function') {
    return f(v)
  } else {
    return f * v
  }
}

function merge (a, b) {
  for (const k in b) a[k] = b[k]
  return a
}
